<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>My map</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>
<link rel="stylesheet" href="{{url_for('static',filename='/styles/map.css')}}">
<style></style>
</head>
<body>
    <div id="container" class="svg-container"></div>
	<script type="text/javascript">

    var eqDomain = [0, 1, 2, 3, 4, 5, 6, 9 ];
    var eqColorScale = d3.scale.linear()
                        .domain(eqDomain)
                        .range(['#fff7ec','#fee8c8',
                                '#fdd49e','#fdbb84',
                                '#fc8d59','#ef6548',
                                '#d7301f','#b30000','#7f0000'
                                ]);  
    var eqSizeScale = d3.scale.linear()
                        .domain(eqDomain)
                        .range([1,1.5,3,4.5,6,7.5,9,13.5])


    
    var w = 1400;
    var h = 700;
    var svg = d3.select("div#container").append("svg").attr("preserveAspectRatio", "xMinYMin meet").style("background-color","#c9e8fd")
    .attr("viewBox", "0 0 " + w + " " + h)
    .classed("svg-content", true);
    var projection = d3.geo.mercator().translate([w/2, h/2]).scale(1500).center([-100,35]);
    var path = d3.geo.path().projection(projection);
        
    // load data  
    var worldmap = d3.json("{{url_for('static',filename='data/world-countries.geojson')}}" );
    var eartquakes = d3.csv("{{url_for('static',filename='data/subset-earthquakes.csv')}}");


d3.json("{{url_for('static',filename='data/world-countries.geojson')}}", function(err,world) {
    if (err) {
      throw err;
    }

    // country boundaries as paths
    var countryBoundaries = svg.selectAll("path");

    // remove all previous country boundaries: on resize, we need to redraw from scratch
    // (could probably transition this nicely, but that's not the focus of this animation)
    countryBoundaries.remove();

    // append the data 
    countryBoundaries.data(world.features)
      .enter()
      .append("path")
      .attr("class", "countries")
      .attr("d", path);

    // DRAW EARTHQUAKES 
    d3.csv("{{url_for('static',filename='data/subset-earthquakes.csv')}}", function(err, earthcsv) {
        console.log(earthcsv)
      
      // get the circle selection and add the data
      var circles = svg.selectAll("circle")
         .remove() // this clears any existing circles we have, which will need updated x/y data on resize
         .data(earthcsv);
      
      
      // on the enter selection, add x,y, radius, and color
      circles.enter()
        .append("circle")
        .attr("cx", function(d) {
              return projection([d.longitude, d.latitude])[0];
            })
        .attr("cy", function(d) {
            return projection([d.longitude, d.latitude])[1];
            })
        .attr("r", 0)
        .transition()
        .duration(900)
        .delay(function(d,i){ return 50*i; })
        .ease('elastic')
        .attr("r", function(d) {
              return eqSizeScale(d.magnitudo);
            }) 
        .style("fill", function(d) {
                return eqColorScale(d.magnitudo);
            })
        .attr("class", "earthquake");
      
      // remove any exit selection
      circles.exit().remove();

      addMagnitudeLegend();
    })
    
})



var addMagnitudeLegend = function()
{
  // create a list of objects representing a legend entry
  // so we can add x,y coordinates to each object and apply text
  // to each magnitude circle:
  // example here: http://stackoverflow.com/questions/11857615/placing-labels-at-the-center-of-nodes-in-d3-js
  var legendObjs = [];
  eqDomain.forEach(function(d,i) {
     legendObjs[i] = { mag: d };
  });
  
  // some sizing and location info
  var lNodeSize = 40;
  var lXOffset = 15; 
  var lYOffset = 5;
  var lTopLeft = [lXOffset, h - lNodeSize - lNodeSize / 3 - lYOffset ];
  var lBottomRight = [ (lNodeSize + 1) * legendObjs.length, h - lYOffset];
  
  // add a bounding rectangle
  svg.append("svg:rect")
      .attr("class", "legend-box")
      .attr("width", lBottomRight[0] - lTopLeft[0] + "px")
      .attr("height", lBottomRight[1] - lTopLeft[1])
      .style("fill", "white")
      .attr("transform","translate("+lTopLeft[0]+","+lTopLeft[1]+")");
   
  // append the data and get the enter selection
  var lnodes = svg.append("svg:g")
      .selectAll("g") 
      .data(legendObjs, function(d,i){ return d.mag; })
      .enter();
          
  // append the circles to the enter selection
  lnodes.append("circle")
        .attr("r", function(d){ return eqSizeScale(d.mag); })
        .attr("class", "earthquake")
        .style("fill", function(d){ return eqColorScale(d.mag); })
        .attr("transform", function(d, i) {
                               d.x = 2 * lXOffset + lNodeSize * i;
                               d.y = lBottomRight[1] - lNodeSize / 2;
                               return "translate("
                                        + d.x + ","+ d.y 
                                        + ")";
                            });
  // append the text to each "svg:g" node, which also contains a circle
  lnodes.append("text")
        .text(function(d) { return "M"+d.mag; })
        .attr("class", "legend-mag-text")
        .attr("text-anchor", "middle" )
        // the transform here contains an offset from the
        // middle of the g element, which is also the middle of the circle
        .style('fill', 'black')
        .attr("transform", function(d) {
                                return "translate("
                                   + d.x + ","
                                   + (d.y-15) + ")"; });
}


   
</script>
</body>
</html>